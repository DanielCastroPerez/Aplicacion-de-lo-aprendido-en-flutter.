[
  {
    "nombre": "Scaffold",
    "descripcion": "Un widget fundamental de Material Design que proporciona una estructura básica para implementar el diseño visual de tu aplicación. Sirve como el 'lienzo' principal donde colocas otros widgets como la barra de aplicación, el cuerpo principal, el botón de acción flotante, etc.",
    "propiedades_detalladas": [
      {
        "nombre": "appBar",
        "tipo": "AppBar",
        "descripcion_extendida": "Una barra en la parte superior de la pantalla. Típicamente muestra el título de la aplicación, acciones y un botón de navegación (como el menú de hamburguesa o el botón de retroceso).",
        "ejemplo_propiedad": "Scaffold(\n  appBar: AppBar(\n    title: const Text('Mi Aplicación'),\n  ),\n  // ... otras propiedades\n)"
      },
      {
        "nombre": "body",
        "tipo": "Widget",
        "descripcion_extendida": "El contenido principal de la pantalla, ubicado debajo del `appBar` y cubriendo la mayor parte del área visible. Aquí es donde colocas la interfaz de usuario central de tu pantalla (listas, formularios, imágenes, etc.).",
        "ejemplo_propiedad": "Scaffold(\n  body: Center(\n    child: Text('¡Hola, Mundo!'),\n  ),\n  // ... otras propiedades\n)"
      },
      {
        "nombre": "floatingActionButton",
        "tipo": "FloatingActionButton",
        "descripcion_extendida": "Un botón circular que flota sobre el contenido del `body`, típicamente usado para la acción principal de la pantalla (ej. añadir un nuevo elemento, componer un correo).",
        "ejemplo_propiedad": "Scaffold(\n  floatingActionButton: FloatingActionButton(\n    onPressed: () {\n      print('Botón flotante presionado');\n    },\n    child: const Icon(Icons.add),\n  ),\n  // ... otras propiedades\n)"
      },
      {
        "nombre": "drawer",
        "tipo": "Drawer",
        "descripcion_extendida": "Un panel deslizante que se muestra desde el borde izquierdo de la pantalla (o derecho en RTL). Comúnmente utilizado para la navegación principal de la aplicación.",
        "ejemplo_propiedad": "Scaffold(\n  drawer: Drawer(\n    child: ListView(\n      padding: EdgeInsets.zero,\n      children: const [\n        DrawerHeader(\n          decoration: BoxDecoration(\n            color: Colors.blue,\n          ),\n          child: Text('Encabezado del Drawer'),\n        ),\n        ListTile(title: Text('Opción 1')),\n        ListTile(title: Text('Opción 2')),\n      ],\n    ),\n  ),\n  // ... otras propiedades\n)"
      },
      {
        "nombre": "bottomNavigationBar",
        "tipo": "BottomNavigationBar",
        "descripcion_extendida": "Una barra en la parte inferior de la pantalla que permite cambiar rápidamente entre un número pequeño de vistas de nivel superior (generalmente entre 3 y 5).",
        "ejemplo_propiedad": "Scaffold(\n  bottomNavigationBar: BottomNavigationBar(\n    items: const [\n      BottomNavigationBarItem(\n        icon: Icon(Icons.home),\n        label: 'Inicio',\n      ),\n      BottomNavigationBarItem(\n        icon: Icon(Icons.settings),\n        label: 'Ajustes',\n      ),\n    ],\n    onTap: (index) { print('Ítem $index seleccionado'); },\n  ),\n  // ... otras propiedades\n)"
      },
      {
        "nombre": "backgroundColor",
        "tipo": "Color",
        "descripcion_extendida": "El color de fondo del Scaffold. Por defecto, es el `scaffoldBackgroundColor` del tema de la aplicación.",
        "ejemplo_propiedad": "Scaffold(\n  backgroundColor: Colors.grey.shade200,\n  body: const Center(child: Text('Fondo Gris Claro')),\n)"
      }
    ],
    "usos_comunes": [
      "La base para casi todas las pantallas de una aplicación Flutter que siguen las guías de Material Design.",
      "Organizar los elementos estructurales de la UI de una manera estándar y predecible."
    ],
    "constructores_comunes": [
      "Scaffold()"
    ],
    "widgets_relacionados": [
      "AppBar",
      "FloatingActionButton",
      "Drawer",
      "BottomNavigationBar",
      "MaterialApp (que contiene el Scaffold)"
    ],
    "cuando_no_usar": "No uses `Scaffold` si estás construyendo un widget muy pequeño y específico que no necesita una estructura de pantalla completa (ej. un elemento de una lista, un botón personalizado). Para esos casos, un `Container` o un widget más simple sería suficiente.",
    "codigo": "Scaffold(\n  appBar: AppBar(title: const Text('Título')),\n  body: const Center(child: Text('Contenido')),\n  floatingActionButton: FloatingActionButton(\n    onPressed: () {},\n    child: const Icon(Icons.add),\n  ),\n);",
    "imagen": "assets/Scaffold.jpg",
    "ruta": "/Page_Scaffold"
  },
  {
    "nombre": "AppBar",
    "descripcion": "Una barra de herramientas de Material Design que se coloca típicamente en la parte superior de un `Scaffold`. Se usa para mostrar el título de la pantalla, iconos de acción, y puede contener un botón de navegación (como el de 'volver' o el de 'menú de hamburguesa').",
    "propiedades_detalladas": [
      {
        "nombre": "title",
        "tipo": "Widget",
        "descripcion_extendida": "El widget principal que se muestra en el centro de la barra. Generalmente, es un widget `Text` que muestra el título de la pantalla actual. Puedes personalizar su estilo con `TextStyle`.",
        "ejemplo_propiedad": "AppBar(\n  title: const Text('Mi Título'),\n)"
      },
      {
        "nombre": "leading",
        "tipo": "Widget",
        "descripcion_extendida": "Un widget opcional que se muestra antes del `title` (a la izquierda) en la `AppBar`. Comúnmente, es un `IconButton` para un menú de navegación (`Icons.menu`) o una flecha de retroceso (`Icons.arrow_back`). Si un `Scaffold` tiene un `Drawer` o si hay una ruta previa en el navegador, Flutter a menudo provee automáticamente un botón `leading`.",
        "ejemplo_propiedad": "AppBar(\n  leading: IconButton(\n    icon: const Icon(Icons.menu),\n    onPressed: () {\n      // Acción para abrir el Drawer\n      Scaffold.of(context).openDrawer();\n    },\n  ),\n  title: const Text('Menú Principal'),\n)"
      },
      {
        "nombre": "actions",
        "tipo": "List<Widget>",
        "descripcion_extendida": "Una lista de widgets que se muestran después del `title` (a la derecha) en la `AppBar`. Usualmente son `IconButtons` para acciones comunes como búsqueda, compartir, o configuraciones. Se muestran en el orden en que se listan.",
        "ejemplo_propiedad": "AppBar(\n  title: const Text('Acciones'),\n  actions: [\n    IconButton(icon: const Icon(Icons.search), onPressed: () { /* Acción de búsqueda */ }),\n    IconButton(icon: const Icon(Icons.settings), onPressed: () { /* Acción de configuración */ }),\n  ],\n)"
      },
      {
        "nombre": "bottom",
        "tipo": "PreferredSizeWidget",
        "descripcion_extendida": "Un widget que se muestra directamente debajo de la `AppBar` principal. Es muy útil para integrar pestañas de navegación (`TabBar`) o cualquier otro widget que necesite anclarse en la parte inferior de la barra de aplicación.",
        "ejemplo_propiedad": "AppBar(\n  title: const Text('Pestañas'),\n  bottom: const TabBar(\n    tabs: [\n      Tab(icon: Icon(Icons.home)),\n      Tab(icon: Icon(Icons.settings)),\n    ],\n  ),\n)"
      },
      {
        "nombre": "backgroundColor",
        "tipo": "Color",
        "descripcion_extendida": "El color de fondo de la `AppBar`. Por defecto, es el `primaryColor` del tema de la aplicación. Puedes personalizarlo para que coincida con la paleta de colores de tu diseño.",
        "ejemplo_propiedad": "AppBar(\n  backgroundColor: Colors.indigo.shade700,\n  title: const Text('Fondo Azul Oscuro'),\n)"
      },
      {
        "nombre": "elevation",
        "tipo": "double",
        "descripcion_extendida": "La sombra visual debajo de la `AppBar`, que le da un efecto de elevación sobre el contenido. Un valor de `0.0` elimina la sombra. Un valor mayor hace la sombra más pronunciada.",
        "ejemplo_propiedad": "AppBar(\n  elevation: 4.0, // Sombra estándar\n  title: const Text('Con Sombra'),\n)"
      }
    ],
    "usos_comunes": [
      "Mostrar el título de la pantalla actual o el nombre de la aplicación.",
      "Proveer botones de navegación (atrás, menú) y acciones rápidas (búsqueda, configuración, guardar).",
      "Integrar barras de pestañas (`TabBar`) para navegación secundaria."
    ],
    "constructores_comunes": [
      "AppBar()"
    ],
    "widgets_relacionados": [
      "Scaffold (el padre común de AppBar)",
      "IconButton (usado frecuentemente en `leading` y `actions`)",
      "TabBar (usado en la propiedad `bottom`)",
      "Text (usado comúnmente en `title`)"
    ],
    "cuando_no_usar": "No uses `AppBar` si la pantalla no necesita una barra de herramientas en la parte superior, o si el diseño es completamente personalizado y no sigue las directrices de Material Design para una barra superior. En esos casos, podrías usar un `Container` o `Row` personalizado para lograr un efecto similar sin las funcionalidades y el estilo predefinidos de `AppBar`.",
    "codigo": "AppBar(\n  centerTitle: true,\n  title: const Text('Aplicación AppBar'),\n  backgroundColor: Colors.orange,\n  actions: [\n    IconButton(\n      icon: const Icon(Icons.settings),\n      onPressed: () {},\n    ),\n  ],\n);",
    "imagen": "assets/AppBar.jpg",
    "ruta": "/Page_AppBar"
  },
  {
    "nombre": "MaterialApp",
    "descripcion": "Un widget que envuelve tu aplicación Flutter para proveer funcionalidades de Material Design. Es la base fundamental para configurar el tema visual de la app, las rutas de navegación, la localización y otras configuraciones a nivel de toda la aplicación.",
    "propiedades_detalladas": [
      {
        "nombre": "home",
        "tipo": "Widget",
        "descripcion_extendida": "El widget que se muestra como la pantalla principal de la aplicación cuando esta se inicia. Es la 'puerta principal' visual de tu app. Si esta propiedad está definida, tendrá prioridad sobre `initialRoute` para la pantalla inicial.",
        "ejemplo_propiedad": "MaterialApp(\n  home: const MyHomePage(), // Define MyHomePage como la pantalla de inicio\n)"
      },
      {
        "nombre": "title",
        "tipo": "String",
        "descripcion_extendida": "Un título descriptivo para la aplicación. Este título es utilizado por el sistema operativo (ej. en el selector de tareas recientes en Android o el app switcher en iOS) para identificar tu aplicación.",
        "ejemplo_propiedad": "MaterialApp(\n  title: 'Mi Gran Aplicación',\n  home: const MyHomePage(),\n)"
      },
      {
        "nombre": "theme",
        "tipo": "ThemeData",
        "descripcion_extendida": "Define el tema visual global de la aplicación (colores principales, tipografías por defecto, formas de los componentes, etc.). Esto ayuda a mantener una apariencia consistente en toda tu UI.",
        "ejemplo_propiedad": "MaterialApp(\n  theme: ThemeData(\n    primarySwatch: Colors.teal,\n    appBarTheme: const AppBarTheme(color: Colors.cyan),\n  ),\n  home: const MyHomePage(),\n)"
      },
      {
        "nombre": "routes",
        "tipo": "Map<String, WidgetBuilder>",
        "descripcion_extendida": "Un mapa de rutas nombradas que la aplicación puede navegar. Cada entrada en el mapa asocia un nombre de ruta (String, ej. '/settings') con una función constructora de widget. Esto permite una navegación limpia y declarativa entre pantallas.\n\n**Nota Importante:** Si usas `routes`, el widget que se muestra al iniciar la app se define con `initialRoute` (si `home` no está presente).",
        "ejemplo_propiedad": "MaterialApp(\n  initialRoute: '/',\n  routes: {\n    '/': (context) => const HomeScreen(),\n    '/settings': (context) => const SettingsScreen(),\n  },\n)"
      },
      {
        "nombre": "initialRoute",
        "tipo": "String",
        "descripcion_extendida": "La ruta con nombre que se carga primero cuando la aplicación se inicia. Esta propiedad es relevante cuando toda tu navegación se basa en rutas nombradas a través de la propiedad `routes` y no estás usando la propiedad `home`.",
        "ejemplo_propiedad": "MaterialApp(\n  initialRoute: '/dashboard', // Inicia en la ruta del dashboard\n  routes: { '/dashboard': (context) => const DashboardScreen() },\n)"
      },
      {
        "nombre": "navigatorKey",
        "tipo": "GlobalKey<NavigatorState>",
        "descripcion_extendida": "Una clave global opcional para acceder al `Navigator` de la aplicación desde cualquier parte del árbol de widgets, incluso fuera del contexto de un widget que conoce el `Navigator` (útil para navegación programática o de servicios).",
        "ejemplo_propiedad": "final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\nMaterialApp(\n  navigatorKey: navigatorKey,\n  home: Builder(\n    builder: (context) => ElevatedButton(\n      onPressed: () => navigatorKey.currentState?.pushNamed('/settings'),\n      child: const Text('Ir a Ajustes (con GlobalKey)'),\n    ),\n  ),\n  routes: {'/settings': (context) => const SettingsScreen()},\n)"
      },
      {
        "nombre": "debugShowCheckedModeBanner",
        "tipo": "bool",
        "descripcion_extendida": "Controla si se muestra la bandera de 'DEBUG' en la esquina superior derecha de la aplicación. Configúrala a `false` para quitarla en producción o al hacer capturas de pantalla limpias.",
        "ejemplo_propiedad": "MaterialApp(\n  debugShowCheckedModeBanner: false, // Oculta la bandera de DEBUG\n  home: const MyHomePage(),\n)"
      }
    ],
    "usos_comunes": [
      "Definir el punto de entrada principal de cualquier aplicación Flutter basada en Material Design.",
      "Configurar el tema visual global (colores, fuentes) para toda la aplicación.",
      "Gestionar la navegación entre diferentes pantallas de la aplicación a través de rutas nombradas."
    ],
    "constructores_comunes": [
      "MaterialApp()",
      "MaterialApp.router() (para integración con paquetes de enrutamiento más avanzados)"
    ],
    "widgets_relacionados": [
      "Scaffold (para la estructura de cada pantalla)",
      "WidgetsApp (el widget padre de MaterialApp para aplicaciones no Material)",
      "ThemeData (para definir el tema)",
      "Navigator (gestiona la pila de rutas)"
    ],
    "cuando_no_usar": "No uses `MaterialApp` si tu aplicación no va a seguir las directrices de diseño de Material Design (por ejemplo, si estás creando una app con un diseño muy personalizado o una app puramente basada en iOS usando `CupertinoApp`). En ese caso, usarías `WidgetsApp` (la base de `MaterialApp` y `CupertinoApp`) y construirías tu UI desde cero.",
    "codigo": "MaterialApp(\n  title: 'Mi Aplicación Flutter',\n  home: Scaffold(\n    appBar: AppBar(title: const Text('Inicio')),\n    body: const Center(child: Text('¡Bienvenido!')),\n  ),\n  theme: ThemeData(primarySwatch: Colors.deepPurple),\n  debugShowCheckedModeBanner: false,\n);",
    "imagen": "assets/MaterialApp.jpg",
    "ruta": "/Page_MaterialApp"
  },
  {
    "nombre": "Container",
    "descripcion": "Un widget flexible y versátil que se utiliza para contener, dimensionar, posicionar y estilizar otros widgets. Es como una caja en la que puedes meter otros elementos, controlando su tamaño, color, bordes, relleno (padding), margen (margin) y sombras. Es fundamental para agrupar elementos y darles un aspecto visual específico.",
    "propiedades_detalladas": [
      {
        "nombre": "child",
        "tipo": "Widget",
        "descripcion_extendida": "El único widget que contendrá el `Container`. Este widget se colocará dentro del área del `Container` y respetará su padding y alineación. Si no se especifica, el `Container` actuará como un espacio vacío estilizado.",
        "ejemplo_propiedad": "Container(\n  color: Colors.lightGreen.shade100,\n  child: Text('Hola desde el Container'),\n)"
      },
      {
        "nombre": "width",
        "tipo": "double",
        "descripcion_extendida": "Define el ancho fijo del contenedor. Si no se especifica, el `Container` intentará ser tan ancho como su padre si no tiene un `child`, o tan ancho como su `child` si lo tiene y no hay otras restricciones.",
        "ejemplo_propiedad": "Container(\n  width: 150.0,\n  height: 100.0,\n  color: Colors.orange.shade200,\n  child: Center(child: Text('150x100')), \n)"
      },
      {
        "nombre": "height",
        "tipo": "double",
        "descripcion_extendida": "Define el alto fijo del contenedor. Similar al `width`, si no se especifica, se ajustará al padre o al `child` según el contexto.",
        "ejemplo_propiedad": "Container(\n  width: 100.0,\n  height: 200.0,\n  color: Colors.purple.shade100,\n  child: Center(child: Text('100x200')), \n)"
      },
      {
        "nombre": "color",
        "tipo": "Color",
        "descripcion_extendida": "Establece el color de fondo del contenedor. **Importante:** Si usas la propiedad `decoration` para estilos más complejos, no puedes usar `color` directamente aquí; el color debe ir dentro de la `decoration` (ej. en `BoxDecoration`).",
        "ejemplo_propiedad": "Container(\n  color: Colors.red,\n  child: Text('Fondo Rojo'),\n)"
      },
      {
        "nombre": "padding",
        "tipo": "EdgeInsetsGeometry",
        "descripcion_extendida": "El espacio interno entre el borde del `Container` y su `child`. Este espacio 'empuja' el contenido hacia adentro desde los bordes del contenedor. Se define usando `EdgeInsets` (ej. `EdgeInsets.all`, `EdgeInsets.only`).",
        "ejemplo_propiedad": "Container(\n  color: Colors.cyan.shade100,\n  padding: EdgeInsets.all(20.0), // 20px de relleno en todos los lados\n  child: Text('Texto con padding'),\n)"
      },
      {
        "nombre": "margin",
        "tipo": "EdgeInsetsGeometry",
        "descripcion_extendida": "El espacio externo entre el `Container` y otros widgets que lo rodean. Este espacio 'separa' el contenedor de sus vecinos. También se define usando `EdgeInsets`.",
        "ejemplo_propiedad": "Container(\n  color: Colors.yellow.shade100,\n  margin: EdgeInsets.only(top: 10.0, bottom: 10.0), // Margen solo arriba y abajo\n  child: Text('Texto con margin'),\n)"
      },
      {
        "nombre": "decoration",
        "tipo": "Decoration",
        "descripcion_extendida": "Permite personalizar el aspecto visual del contenedor de formas más avanzadas que solo el `color`. Puedes definir bordes, esquinas redondeadas, gradientes, imágenes de fondo y sombras de caja. Si usas `decoration`, el `color` del `Container` debe ir dentro de la `BoxDecoration`.",
        "ejemplo_propiedad": "Container(\n  decoration: BoxDecoration(\n    color: Colors.blueAccent,\n    borderRadius: BorderRadius.circular(10.0), // Esquinas redondeadas\n    border: Border.all(color: Colors.black, width: 2), // Borde\n    boxShadow: [\n      BoxShadow(\n        color: Colors.black.withOpacity(0.3),\n        spreadRadius: 3,\n        blurRadius: 5,\n        offset: Offset(0, 3),\n      ),\n    ],\n  ),\n  child: Text('Caja decorada'),\n)"
      },
      {
        "nombre": "alignment",
        "tipo": "AlignmentGeometry",
        "descripcion_extendida": "Cómo se alinea el `child` dentro del `Container` si el `Container` es más grande que su `child`. Por defecto, el `child` se alinea al centro (`Alignment.center`). Puedes especificar otras alineaciones como `Alignment.topLeft`, `Alignment.bottomRight`, etc.",
        "ejemplo_propiedad": "Container(\n  width: 200,\n  height: 200,\n  color: Colors.grey.shade300,\n  alignment: Alignment.bottomRight, // Alinea el hijo a la esquina inferior derecha\n  child: Text('Aquí abajo'),\n)"
      },
      {
        "nombre": "constraints",
        "tipo": "BoxConstraints",
        "descripcion_extendida": "Define restricciones de tamaño adicionales para el `Container`, como un ancho o alto mínimo/máximo. Esto te da un control más fino sobre cómo el `Container` se ajusta a los límites de su padre o de su contenido. Por ejemplo, `BoxConstraints.expand()` hará que el Container ocupe todo el espacio disponible.",
        "ejemplo_propiedad": "Container(\n  constraints: BoxConstraints.expand(width: 100, height: 100), // Fuerza un tamaño exacto\n  color: Colors.pink.shade100,\n  child: Text('Tamaño fijo'),\n)"
      }
    ],
    "usos_comunes": [
      "Crear tarjetas, paneles o secciones con estilos personalizados (colores de fondo, bordes, sombras).",
      "Establecer dimensiones específicas (ancho, alto) para un widget o un espacio.",
      "Añadir espaciado interno (padding) o externo (margin) alrededor de los elementos.",
      "Agrupar múltiples widgets para aplicarles un estilo o un posicionamiento conjunto."
    ],
    "constructores_comunes": [
      "Container()"
    ],
    "widgets_relacionados": [
      "SizedBox (para espacios vacíos con tamaño fijo)",
      "Padding (solo para aplicar relleno)",
      "DecoratedBox (si solo necesitas la decoración)",
      "Align (si solo necesitas alinear un hijo)",
      "Center (si solo necesitas centrar un hijo)"
    ],
    "cuando_no_usar": "Aunque `Container` es muy versátil, no lo uses si solo necesitas una funcionalidad específica que otro widget hace de forma más eficiente y ligera. Por ejemplo:\n- Si solo necesitas espacio vacío, usa `SizedBox`.\n- Si solo necesitas aplicar padding, usa `Padding`.\n- Si solo necesitas centrar un widget, usa `Center`.\n- Si solo necesitas un color de fondo, `ColoredBox` es más simple.\nUsar `Container` por defecto para todo puede añadir un ligero overhead si sus capacidades avanzadas no son necesarias.",
    "codigo": "Container(\n  padding: const EdgeInsets.all(16),\n  margin: const EdgeInsets.symmetric(vertical: 10),\n  decoration: BoxDecoration(\n    color: Colors.blue[100],\n    borderRadius: BorderRadius.circular(12),\n    border: Border.all(color: Colors.blue, width: 2),\n  ),\n  width: double.infinity,\n  child: const Text(\n    'Este es un ejemplo de Container',\n    style: TextStyle(fontSize: 18),\n    textAlign: TextAlign.center,\n  ),\n);",
    "imagen": "assets/Container.jpg",
    "ruta": "/Page_Container"
  },
  {
    "nombre": "Column",
    "descripcion": "Un widget de diseño que organiza sus `children` (hijos) en una secuencia **vertical**. Es fundamental para construir interfaces donde los elementos se apilan uno encima del otro, adaptándose al espacio disponible y a la alineación que definas.",
    "propiedades_detalladas": [
      {
        "nombre": "children",
        "tipo": "List<Widget>",
        "descripcion_extendida": "La lista de widgets que se mostrarán verticalmente, uno debajo del otro, dentro de la columna. Siempre se espera una lista de widgets, incluso si es solo uno.",
        "ejemplo_propiedad": "Column(\n  children: [\n    Text('Primer ítem'),\n    Text('Segundo ítem'),\n  ],\n)"
      },
      {
        "nombre": "mainAxisAlignment",
        "tipo": "MainAxisAlignment",
        "descripcion_extendida": "Define cómo se alinean los hijos a lo largo del **eje principal (vertical)** de la columna. Este eje va de arriba a abajo. Las opciones comunes son:\n    - **`MainAxisAlignment.start`**: Alinea los hijos al principio del eje (arriba).\n    - **`MainAxisAlignment.center`**: Centra los hijos en el eje.\n    - **`MainAxisAlignment.end`**: Alinea los hijos al final del eje (abajo).\n    - **`MainAxisAlignment.spaceBetween`**: Distribuye el espacio sobrante uniformemente entre los hijos, con el primer hijo al principio y el último al final.\n    - **`MainAxisAlignment.spaceAround`**: Distribuye el espacio sobrante uniformemente alrededor de cada hijo (incluyendo espacio antes del primero y después del último).\n    - **`MainAxisAlignment.spaceEvenly`**: Distribuye el espacio sobrante uniformemente tanto entre los hijos como antes del primero y después del último, resultando en espacios del mismo tamaño.",
        "ejemplo_propiedad": "Column(\n  mainAxisAlignment: MainAxisAlignment.center, // Centra los hijos verticalmente\n  children: const [\n    Icon(Icons.star),\n    Text('Estrellas'),\n  ],\n)"
      },
      {
        "nombre": "crossAxisAlignment",
        "tipo": "CrossAxisAlignment",
        "descripcion_extendida": "Define cómo se alinean los hijos a lo largo del **eje transversal (horizontal)** de la columna. Este eje va de izquierda a derecha. Las opciones comunes son:\n    - **`CrossAxisAlignment.start`**: Alinea los hijos al principio del eje transversal (izquierda).\n    - **`CrossAxisAlignment.center`**: Centra los hijos en el eje transversal.\n    - **`CrossAxisAlignment.end`**: Alinea los hijos al final del eje transversal (derecha).\n    - **`CrossAxisAlignment.stretch`**: Estira los hijos para que llenen todo el espacio disponible a lo largo del eje transversal. Muy útil para que los hijos ocupen todo el ancho de la `Column`.\n    - **`CrossAxisAlignment.baseline`**: Alinea los hijos en base a su línea base de texto (útil cuando se mezclan textos de diferentes tamaños, requiere `textBaseline`).",
        "ejemplo_propiedad": "Column(\n  crossAxisAlignment: CrossAxisAlignment.stretch, // Estira los hijos horizontalmente\n  children: [\n    Container(height: 50, color: Colors.red),\n    Container(height: 50, color: Colors.blue),\n  ],\n)"
      },
      {
        "nombre": "mainAxisSize",
        "tipo": "MainAxisSize",
        "descripcion_extendida": "Determina cuánto espacio debe ocupar la columna a lo largo de su **eje principal (vertical)**. Las opciones son:\n    - **`MainAxisSize.max`**: La `Column` intentará ocupar todo el espacio vertical disponible (por defecto).\n    - **`MainAxisSize.min`**: La `Column` ocupará solo el espacio vertical mínimo necesario para contener a sus `children`. Útil si no quieres que ocupe todo el alto disponible.",
        "ejemplo_propiedad": "Column(\n  mainAxisSize: MainAxisSize.min, // La columna solo ocupará el alto necesario\n  children: const [\n    Text('Texto Corto'),\n    Text('Otro Texto Más Corto'),\n  ],\n)"
      }
    ],
    "usos_comunes": [
      "Crear listas de elementos apilados (menus, formularios).",
      "Organizar componentes de una tarjeta verticalmente (imagen arriba, texto abajo).",
      "Estructurar la disposición principal de una sección de la UI."
    ],
    "constructores_comunes": [
      "Column()"
    ],
    "widgets_relacionados": [
      "Row (para disposición horizontal)",
      "Expanded (para dar espacio flexible a un hijo en la Column/Row)",
      "Flexible (similar a Expanded, pero con menos rigidez)",
      "ListView (para listas desplazables de muchos elementos)"
    ],
    "cuando_no_usar": "No uses `Column` para listas muy largas o infinitas, ya que carga y renderiza *todos* sus hijos a la vez, lo que puede afectar seriamente el rendimiento. Para eso, es mucho más eficiente usar widgets como `ListView.builder` o `CustomScrollView` que renderizan elementos a medida que son necesarios (visibles en pantalla). Tampoco la uses si necesitas que los elementos se superpongan (usa `Stack`) o si solo tienes un hijo y no necesitas el manejo de alineación que una `Column` ofrece (un `Container` o el widget directamente sería más simple).",
    "codigo": "Column(\n  mainAxisAlignment: MainAxisAlignment.center,\n  crossAxisAlignment: CrossAxisAlignment.center,\n  children: const [\n    Icon(Icons.star, size: 50, color: Colors.amber),\n    SizedBox(height: 10),\n    Text('Productos Favoritos',\n      style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n    ),\n    SizedBox(height: 5),\n    Text('Organizados verticalmente.', style: TextStyle(color: Colors.grey)),\n  ],\n);",
    "imagen": "assets/Column.jpg",
    "ruta": "/Page_Column"
  },
  {
    "nombre": "Row",
    "descripcion": "Un widget de diseño que organiza sus `children` (hijos) en una secuencia **horizontal**. Es esencial para construir interfaces donde los elementos se colocan uno al lado del otro, adaptándose al espacio disponible y a la alineación que definas.",
    "propiedades_detalladas": [
      {
        "nombre": "children",
        "tipo": "List<Widget>",
        "descripcion_extendida": "La lista de widgets que se mostrarán horizontalmente, uno junto al otro, dentro de la fila. Siempre se espera una lista de widgets, incluso si es solo uno.",
        "ejemplo_propiedad": "Row(\n  children: [\n    Text('Izquierda'),\n    Text('Derecha'),\n  ],\n)"
      },
      {
        "nombre": "mainAxisAlignment",
        "tipo": "MainAxisAlignment",
        "descripcion_extendida": "Define cómo se alinean los hijos a lo largo del **eje principal (horizontal)** de la fila. Este eje va de izquierda a derecha. Las opciones comunes son:\n    - **`MainAxisAlignment.start`**: Alinea los hijos al principio del eje (izquierda).\n    - **`MainAxisAlignment.center`**: Centra los hijos en el eje.\n    - **`MainAxisAlignment.end`**: Alinea los hijos al final del eje (derecha).\n    - **`MainAxisAlignment.spaceBetween`**: Distribuye el espacio sobrante uniformemente entre los hijos, con el primer hijo al principio y el último al final.\n    - **`MainAxisAlignment.spaceAround`**: Distribuye el espacio sobrante uniformemente alrededor de cada hijo (incluyendo espacio antes del primero y después del último).\n    - **`MainAxisAlignment.spaceEvenly`**: Distribuye el espacio sobrante uniformemente tanto entre los hijos como antes del primero y después del último, resultando en espacios del mismo tamaño.",
        "ejemplo_propiedad": "Row(\n  mainAxisAlignment: MainAxisAlignment.spaceAround, // Distribuye los hijos con espacio alrededor\n  children: const [\n    Icon(Icons.thumb_up),\n    Text('Me gusta'),\n    Icon(Icons.comment),\n  ],\n)"
      },
      {
        "nombre": "crossAxisAlignment",
        "tipo": "CrossAxisAlignment",
        "descripcion_extendida": "Define cómo se alinean los hijos a lo largo del **eje transversal (vertical)** de la fila. Este eje va de arriba a abajo. Las opciones comunes son:\n    - **`CrossAxisAlignment.start`**: Alinea los hijos al principio del eje transversal (arriba).\n    - **`CrossAxisAlignment.center`**: Centra los hijos en el eje transversal (por defecto si no se especifica y no hay `Expanded`/`Flexible`).\n    - **`CrossAxisAlignment.end`**: Alinea los hijos al final del eje transversal (abajo).\n    - **`CrossAxisAlignment.stretch`**: Estira los hijos para que llenen todo el espacio disponible a lo largo del eje transversal (ocupando todo el alto de la `Row`).\n    - **`CrossAxisAlignment.baseline`**: Alinea los hijos en base a su línea base de texto (útil cuando se mezclan textos de diferentes tamaños, requiere `textBaseline`).",
        "ejemplo_propiedad": "Row(\n  crossAxisAlignment: CrossAxisAlignment.center, // Centra los hijos verticalmente\n  children: [\n    const Text('Título Grande', style: TextStyle(fontSize: 30)),\n    const SizedBox(width: 10),\n    const Text('Subtítulo Pequeño'),\n  ],\n)"
      },
      {
        "nombre": "mainAxisSize",
        "tipo": "MainAxisSize",
        "descripcion_extendida": "Determina cuánto espacio debe ocupar la fila a lo largo de su **eje principal (horizontal)**. Las opciones son:\n    - **`MainAxisSize.max`**: La `Row` intentará ocupar todo el espacio horizontal disponible (por defecto).\n    - **`MainAxisSize.min`**: La `Row` ocupará solo el espacio horizontal mínimo necesario para contener a sus `children`. Útil si no quieres que ocupe todo el ancho disponible.",
        "ejemplo_propiedad": "Row(\n  mainAxisSize: MainAxisSize.min, // La fila solo ocupará el ancho necesario\n  children: const [\n    Chip(label: Text('Etiqueta 1')),\n    Chip(label: Text('Etiqueta 2')),\n  ],\n)"
      }
    ],
    "usos_comunes": [
      "Crear barras de botones o iconos.",
      "Diseñar la disposición de elementos dentro de una tarjeta o lista (ej. icono, título, subtítulo).",
      "Organizar componentes de un formulario horizontalmente.",
      "Alinear elementos de una barra de navegación inferior."
    ],
    "constructores_comunes": [
      "Row()"
    ],
    "widgets_relacionados": [
      "Column (para disposición vertical)",
      "Expanded (para dar espacio flexible a un hijo en la Row/Column)",
      "Flexible (similar a Expanded, pero con menos rigidez)",
      "Wrap (para elementos que se envuelven a la siguiente línea si no hay espacio)",
      "Spacer (para crear espacio flexible entre elementos)"
    ],
    "cuando_no_usar": "No uses `Row` si esperas que el contenido pueda exceder el ancho de la pantalla y necesites que se envuelva automáticamente a la siguiente línea (para eso, usa `Wrap`). Tampoco es adecuada para listas desplazables muy largas de elementos horizontales si no se envuelve en un `SingleChildScrollView` o `ListView.builder` con `scrollDirection: Axis.horizontal`.",
    "codigo": "Row(\n  mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n  children: const [\n    Icon(Icons.home, size: 40),\n    Text('Inicio'),\n    Icon(Icons.search, size: 40),\n    Text('Buscar'),\n    Icon(Icons.settings, size: 40),\n    Text('Ajustes'),\n  ],\n);",
    "imagen": "assets/Row.jpg",
    "ruta": "/Page_Row"
  },
  {
    "nombre": "Text",
    "descripcion": "Un widget fundamental en Flutter que se utiliza para mostrar una cadena de texto inmutable en la interfaz de usuario. Es la forma más básica y común de presentar información textual al usuario.",
    "propiedades_detalladas": [
      {
        "nombre": "data",
        "tipo": "String",
        "descripcion_extendida": "La cadena de texto (el contenido real) que el widget `Text` va a mostrar. Es un parámetro posicional y, por lo tanto, el más importante del widget.",
        "ejemplo_propiedad": "Text('¡Hola, Flutter!')"
      },
      {
        "nombre": "style",
        "tipo": "TextStyle",
        "descripcion_extendida": "Define el estilo visual completo del texto. Acepta un objeto `TextStyle` que es una clase de configuración clave. Con `TextStyle` puedes personalizar ampliamente la apariencia del texto, incluyendo:\n    - **`color`**: El color del texto (ej. `Colors.blue`).\n    - **`fontSize`**: El tamaño de la fuente en píxeles lógicos (ej. `24.0`).\n    - **`fontWeight`**: El grosor de la fuente (ej. `FontWeight.bold` para negrita, `FontWeight.w700`).\n    - **`fontStyle`**: El estilo de la fuente (ej. `FontStyle.italic` para cursiva, `FontStyle.normal`).\n    - **`fontFamily`**: La familia de la fuente (el tipo de letra, ej. 'Roboto', 'OpenSans', o fuentes personalizadas).\n    - **`decoration`**: Decoraciones como `TextDecoration.underline` (subrayado), `TextDecoration.lineThrough` (tachado), `TextDecoration.overline`.\n    - **`decorationColor`**: El color de la decoración.\n    - **`decorationStyle`**: El estilo de la línea de decoración (ej. `TextDecorationStyle.wavy`).\n    - **`letterSpacing`**: El espacio horizontal adicional entre los caracteres del texto.\n    - **`wordSpacing`**: El espacio horizontal adicional entre las palabras del texto.\n    - **`height`**: La altura de la línea de texto, como un multiplicador del `fontSize` (ej. `1.5` para 150% de la altura normal).\n    - **`shadows`**: Una lista de sombras para aplicar al texto (`List<Shadow>`), cada una con su `offset`, `blurRadius` y `color`.\n    - **`background`**: Un `Paint` para dibujar un color o patrón de fondo *detrás* del texto (no el fondo del widget `Text` en sí).\n\n    Es inmutable; para modificar un estilo, creas una nueva instancia (`.copyWith()`). Hereda valores del `Theme` de la aplicación.",
        "ejemplo_propiedad": "Text(\n  'Texto Estilizado',\n  style: TextStyle(\n    color: Colors.deepPurple,\n    fontSize: 22.0,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n    decoration: TextDecoration.underline,\n    decorationColor: Colors.red,\n    decorationStyle: TextDecorationStyle.wavy,\n  ),\n)"
      },
      {
        "nombre": "textAlign",
        "tipo": "TextAlign",
        "descripcion_extendida": "Define cómo se alinea el texto horizontalmente dentro del espacio disponible que ocupa el widget `Text`. Las opciones incluyen `TextAlign.left`, `TextAlign.center`, `TextAlign.right`, `TextAlign.justify` (para texto justificado en bloques).",
        "ejemplo_propiedad": "Text(\n  'Este texto está centrado.',\n  textAlign: TextAlign.center,\n)"
      },
      {
        "nombre": "maxLines",
        "tipo": "int",
        "descripcion_extendida": "El número máximo de líneas que el texto puede ocupar. Si el texto excede este límite, se aplicará el comportamiento definido por la propiedad `overflow`.",
        "ejemplo_propiedad": "Text(\n  'Un texto muy largo que se limitará a una sola línea.',\n  maxLines: 1,\n  overflow: TextOverflow.ellipsis,\n)"
      },
      {
        "nombre": "overflow",
        "tipo": "TextOverflow",
        "descripcion_extendida": "Determina cómo se maneja el texto si excede el espacio disponible o el `maxLines` especificado. Las opciones comunes son:\n    - **`TextOverflow.ellipsis`**: Añade puntos suspensivos (...) al final del texto.\n    - **`TextOverflow.fade`**: Difumina el final del texto.\n    - **`TextOverflow.clip`**: Simplemente recorta el texto sin añadir ningún indicador.\n    - **`TextOverflow.visible`**: El texto se desborda y puede renderizarse fuera de su caja (a menudo no deseado).",
        "ejemplo_propiedad": "Text(\n  'Mucho texto para una pequeña área. Mucho texto para una pequeña área.',\n  maxLines: 1,\n  overflow: TextOverflow.fade,\n)"
      },
      {
        "nombre": "textDirection",
        "tipo": "TextDirection",
        "descripcion_extendida": "La dirección en la que se renderiza el texto (de izquierda a derecha o de derecha a izquierda). Es crucial para el soporte de idiomas RTL (Right-To-Left) como el árabe o el hebreo.\n    - **`TextDirection.ltr`**: Izquierda a derecha (por defecto en la mayoría de los casos).\n    - **`TextDirection.rtl`**: Derecha a izquierda.",
        "ejemplo_propiedad": "Text(\n  'Texto de prueba en RTL',\n  textDirection: TextDirection.rtl,\n)"
      }
    ],
    "usos_comunes": [
      "Mostrar cualquier tipo de información textual en la UI, como títulos, párrafos, etiquetas, descripciones.",
      "Etiquetas para botones, campos de entrada o iconos.",
      "Mensajes informativos o de estado para el usuario."
    ],
    "constructores_comunes": [
      "Text()",
      "Text.rich() (para mostrar texto con múltiples estilos dentro de la misma cadena)"
    ],
    "widgets_relacionados": [
      "RichText (cuando necesitas mezclar muchos estilos diferentes en un solo bloque de texto o aplicar gestos a partes específicas del texto).",
      "DefaultTextStyle (para establecer un estilo de texto predeterminado que los widgets `Text` hijos pueden heredar).",
      "TextField (para entrada de texto editable por el usuario).",
      "SelectableText (para texto que el usuario puede seleccionar y copiar)."
    ],
    "cuando_no_usar": "No uses `Text` si necesitas que el usuario pueda introducir o modificar el texto (para eso, `TextField` es la opción). Tampoco lo uses para texto que requiera interactividad avanzada en partes específicas (ej. un link clicable dentro de un párrafo), donde `Text.rich` o `RichText` serían más adecuados.",
    "codigo": "Text(\n  'Hola Mundo Flutter! Esto es un ejemplo de texto.',\n  style: TextStyle(\n    color: Colors.blueAccent,\n    fontSize: 20.0,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n    letterSpacing: 0.5,\n    decoration: TextDecoration.underline,\n    decorationColor: Colors.red,\n  ),\n  textAlign: TextAlign.center,\n  maxLines: 2,\n  overflow: TextOverflow.ellipsis,\n);",
    "imagen": "assets/Text.jpg",
    "ruta": "/Page_Text"
  },
  {
    "nombre": "SingleChildScrollView",
    "descripcion": "Un widget que hace que su único `child` (hijo) sea desplazable. Es ideal cuando tienes contenido que podría exceder el tamaño de la pantalla, como un formulario largo, una página de detalles o un texto extenso, y necesitas que el usuario pueda desplazarse para ver todo el contenido. A diferencia de `ListView`, solo maneja un único hijo.",
    "propiedades_detalladas": [
      {
        "nombre": "child",
        "tipo": "Widget",
        "descripcion_extendida": "El único widget que será desplazable. Puede ser cualquier widget, pero a menudo es un `Column` o un `Row` que contiene a su vez múltiples widgets, los cuales colectivamente exceden el espacio de la pantalla.",
        "ejemplo_propiedad": "SingleChildScrollView(\n  child: Column(\n    children: [\n      // ... widgets que pueden exceder la pantalla\n    ],\n  ),\n)"
      },
      {
        "nombre": "scrollDirection",
        "tipo": "Axis",
        "descripcion_extendida": "Define la dirección en la que el contenido se puede desplazar. Por defecto es `Axis.vertical` (desplazamiento de arriba a abajo). Puedes cambiarlo a `Axis.horizontal` para un desplazamiento de izquierda a derecha.",
        "ejemplo_propiedad": "SingleChildScrollView(\n  scrollDirection: Axis.horizontal, // Habilita el desplazamiento horizontal\n  child: Row(\n    children: [\n      Container(width: 200, height: 100, color: Colors.red),\n      Container(width: 200, height: 100, color: Colors.blue),\n    ],\n  ),\n)"
      },
      {
        "nombre": "padding",
        "tipo": "EdgeInsetsGeometry",
        "descripcion_extendida": "El espacio vacío que se añade alrededor del `child` dentro del área de desplazamiento. Esto es útil para que el contenido no se pegue a los bordes del área de desplazamiento. Se define usando `EdgeInsets`.",
        "ejemplo_propiedad": "SingleChildScrollView(\n  padding: const EdgeInsets.all(20.0), // Añade 20px de relleno alrededor del contenido\n  child: Text('Contenido con padding desplazable'),\n)"
      },
      {
        "nombre": "physics",
        "tipo": "ScrollPhysics",
        "descripcion_extendida": "Determina cómo se comporta el desplazamiento. Por defecto, adapta la física al sistema operativo (ej. efecto de rebote en iOS, efecto de sobre-desplazamiento en Android). Puedes usar `NeverScrollableScrollPhysics()` para deshabilitar el desplazamiento, o `BouncingScrollPhysics()` para forzar el rebote en todas las plataformas.",
        "ejemplo_propiedad": "SingleChildScrollView(\n  physics: const BouncingScrollPhysics(), // Fuerza el efecto de rebote al final del desplazamiento\n  child: Text('Contenido con física de rebote'),\n)"
      },
      {
        "nombre": "controller",
        "tipo": "ScrollController",
        "descripcion_extendida": "Un controlador opcional que te permite controlar programáticamente la posición de desplazamiento (ej. desplazarse a una posición específica, leer la posición actual) o escuchar eventos de desplazamiento.",
        "ejemplo_propiedad": "final ScrollController _scrollController = ScrollController();\n\n// En tu widget:\nSingleChildScrollView(\n  controller: _scrollController,\n  child: Column(\n    children: [\n      // ... contenido\n      ElevatedButton(\n        onPressed: () => _scrollController.animateTo(\n          _scrollController.position.maxScrollExtent, // Desplazarse al final\n          duration: const Duration(seconds: 1),\n          curve: Curves.easeOut,\n        ),\n        child: const Text('Ir al Final'),\n      ),\n    ],\n  ),\n)"
      }
    ],
    "usos_comunes": [
      "Hacer que formularios largos sean desplazables.",
      "Permitir el desplazamiento en pantallas de detalles de productos o perfiles de usuario que pueden tener mucho contenido.",
      "Cuando el contenido es dinámico y podría exceder el tamaño de la pantalla en diferentes dispositivos o con diferentes datos."
    ],
    "constructores_comunes": [
      "SingleChildScrollView()"
    ],
    "widgets_relacionados": [
      "Column (usado frecuentemente como hijo para organizar verticalmente)",
      "Row (usado como hijo si `scrollDirection` es horizontal)",
      "ListView (para listas de elementos optimizadas con desplazamiento, que construyen elementos bajo demanda)",
      "CustomScrollView (para efectos de desplazamiento más avanzados y combinados)",
      "Scrollbar (para añadir una barra de desplazamiento visual)"
    ],
    "cuando_no_usar": "No uses `SingleChildScrollView` para listas largas o infinitas de elementos (`ListView` es mucho más eficiente, ya que solo renderiza los elementos que son visibles en pantalla). `SingleChildScrollView` renderiza *todo* su `child` a la vez, lo que puede causar problemas de rendimiento si el contenido es excesivamente grande o complejo.",
    "codigo": "SingleChildScrollView(\n  padding: const EdgeInsets.all(20.0),\n  child: Column(\n    crossAxisAlignment: CrossAxisAlignment.start,\n    children: [ \n      const Text('Título Largo de Contenido Desplazable', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),\n      const SizedBox(height: 15),\n      Image.network('https://picsum.photos/400/300'),\n      const SizedBox(height: 15),\n      const Text(\n        'Este es un párrafo de texto muy largo que demuestra cómo SingleChildScrollView permite que todo el contenido sea visible a través del desplazamiento. Es útil para formularios, artículos o cualquier sección de la UI que pueda exceder los límites de la pantalla en dispositivos pequeños.',\n        style: TextStyle(fontSize: 16),\n        textAlign: TextAlign.justify,\n      ),\n      const SizedBox(height: 50), // Espacio al final para ver el desplazamiento\n      ElevatedButton(onPressed: () {}, child: const Text('Ir arriba')),\n    ],\n  ),\n);",
    "imagen": "assets/SingleChildScrollView.jpg",
    "ruta": "/Page_SingleChildScrollView"
  },
  {
    "nombre": "Image",
    "descripcion": "Un widget que se utiliza para mostrar imágenes en tu aplicación Flutter. Es increíblemente versátil, permitiéndote cargar imágenes desde diferentes fuentes: assets locales (paquete de la app), archivos en el dispositivo, la red (URLs) o incluso memoria.",
    "propiedades_detalladas": [
      {
        "nombre": "image",
        "tipo": "ImageProvider",
        "descripcion_extendida": "La fuente de la imagen. No es un `Widget`, sino un `ImageProvider` que sabe cómo cargar los datos de la imagen. Los `ImageProvider` más comunes son:\n    - **`AssetImage`**: Para imágenes empaquetadas con tu app (desde la carpeta `assets`). Requiere que la ruta de la imagen esté declarada en `pubspec.yaml`.\n    - **`NetworkImage`**: Para imágenes cargadas desde una URL de internet.\n    - **`FileImage`**: Para imágenes cargadas desde un archivo en el sistema de archivos del dispositivo.\n    - **`MemoryImage`**: Para imágenes cargadas desde un `Uint8List` (bytes en memoria).",
        "ejemplo_propiedad": "Image(\n  image: AssetImage('assets/my_local_image.png'),\n)\n\nImage(\n  image: NetworkImage('https://picsum.photos/250/200'),\n)"
      },
      {
        "nombre": "width",
        "tipo": "double",
        "descripcion_extendida": "Define el ancho deseado de la imagen en píxeles lógicos. Si no se especifica, la imagen se dimensionará automáticamente según sus restricciones parentales o su tamaño intrínseco.",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://picsum.photos/250/200'),\n  width: 100.0,\n)"
      },
      {
        "nombre": "height",
        "tipo": "double",
        "descripcion_extendida": "Define el alto deseado de la imagen en píxeles lógicos. Similar al `width`, si no se especifica, el alto se ajustará automáticamente.",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://picsum.photos/250/200'),\n  height: 150.0,\n)"
      },
      {
        "nombre": "fit",
        "tipo": "BoxFit",
        "descripcion_extendida": "Determina cómo se debe escalar la imagen para encajar en el espacio asignado por `width` y `height` o por sus restricciones parentales. Opciones comunes:\n    - **`BoxFit.cover`**: Escala la imagen uniformemente para que cubra completamente la caja, recortando cualquier parte que no quepa. Ideal para fondos o miniaturas.\n    - **`BoxFit.contain`**: Escala la imagen uniformemente para que quepa completamente dentro de la caja, dejando espacio vacío si es necesario (manteniendo la relación de aspecto).\n    - **`BoxFit.fill`**: Estira la imagen para que llene completamente la caja, ignorando su relación de aspecto (puede distorsionar la imagen).\n    - **`BoxFit.fitWidth`**: Escala la imagen para que su ancho coincida con el ancho de la caja, ajustando el alto proporcionalmente.\n    - **`BoxFit.fitHeight`**: Escala la imagen para que su alto coincida con el alto de la caja, ajustando el ancho proporcionalmente.\n    - **`BoxFit.none`**: No escala la imagen; simplemente la dibuja en su tamaño original en la parte superior izquierda de la caja (puede desbordarse).",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://picsum.photos/250/200'),\n  width: 100.0,\n  height: 100.0,\n  fit: BoxFit.cover, // La imagen llenará el espacio de 100x100, recortando si es necesario\n)"
      },
      {
        "nombre": "alignment",
        "tipo": "AlignmentGeometry",
        "descripcion_extendida": "Define cómo se alinea la imagen dentro de su espacio asignado si la imagen es más pequeña que la caja después de aplicar `fit`. Por defecto, es `Alignment.center`.",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://picsum.photos/250/200'),\n  width: 200.0,\n  height: 200.0,\n  fit: BoxFit.contain, // La imagen se ajusta al espacio\n  alignment: Alignment.bottomLeft, // La imagen se alinea a la parte inferior izquierda de la caja\n)"
      },
      {
        "nombre": "color",
        "tipo": "Color",
        "descripcion_extendida": "Un color opcional que se mezcla con los píxeles de la imagen. Útil para aplicar tintes o filtros de color a una imagen.",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://picsum.photos/250/200'),\n  color: Colors.blue.withOpacity(0.5), // Tinte azul semitransparente\n  colorBlendMode: BlendMode.srcATop,\n)"
      },
      {
        "nombre": "errorBuilder",
        "tipo": "ImageErrorWidgetBuilder",
        "descripcion_extendida": "Una función opcional que se llama si la imagen no se puede cargar (ej. URL incorrecta, archivo no encontrado). Permite mostrar un widget de reemplazo (ej. un icono de error) en lugar de simplemente fallar silenciosamente.",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://url.invalida/imagen.jpg'),\n  errorBuilder: (context, error, stackTrace) {\n    return const Icon(Icons.broken_image, size: 50, color: Colors.red);\n  },\n)"
      },
      {
        "nombre": "loadingBuilder",
        "tipo": "ImageLoadingBuilder",
        "descripcion_extendida": "Una función opcional que se llama mientras la imagen se está cargando. Permite mostrar un widget de marcador de posición (ej. un `CircularProgressIndicator`) mientras la imagen se descarga de la red o se carga desde el disco.",
        "ejemplo_propiedad": "Image(\n  image: NetworkImage('https://picsum.photos/250/200'),\n  loadingBuilder: (context, child, loadingProgress) {\n    if (loadingProgress == null) return child;\n    return Center(\n      child: CircularProgressIndicator(\n        value: loadingProgress.expectedTotalBytes != null\n            ? loadingProgress.cumulativeBytesLoaded / loadingProgress.expectedTotalBytes!\n            : null,\n      ),\n    );\n  },\n)"
      }
    ],
    "usos_comunes": [
      "Mostrar logotipos y gráficos de la aplicación.",
      "Presentar imágenes de productos, avatares de usuario o fondos.",
      "Integrar imágenes de la web o de la galería del usuario."
    ],
    "constructores_comunes": [
      "Image.asset()",
      "Image.network()",
      "Image.file()",
      "Image.memory()",
      "Image() (usando directamente ImageProvider)"
    ],
    "widgets_relacionados": [
      "FadeInImage (para imágenes que aparecen gradualmente)",
      "CircleAvatar (para avatares circulares)",
      "CachedNetworkImage (un paquete popular para el manejo avanzado de imágenes en red, incluyendo caché y placeholders)"
    ],
    "cuando_no_usar": "No uses `Image.network` si necesitas un control avanzado de caché para imágenes de red (considera usar un paquete como `cached_network_image`). Tampoco lo uses si necesitas una imagen con bordes especiales que el widget no pueda lograr por sí solo; en esos casos, `ClipRRect` o `Container` con `decoration` e `image` pueden ser más adecuados.",
    "codigo": "Image.network(\n  'https://picsum.photos/300/200',\n  width: 300,\n  height: 200,\n  fit: BoxFit.cover,\n  loadingBuilder: (context, child, loadingProgress) {\n    if (loadingProgress == null) return child;\n    return const Center(child: CircularProgressIndicator());\n  },\n  errorBuilder: (context, error, stackTrace) {\n    return const Icon(Icons.broken_image, size: 100, color: Colors.grey);\n  },\n);",
    "imagen": "assets/Image.jpg",
    "ruta": "/Page_Image"
  },
  {
    "nombre": "Card",
    "descripcion": "Un widget de Material Design que representa una \"tarjeta\" en la interfaz de usuario. Las tarjetas son superficies que contienen contenido y acciones sobre un tema único. Se caracterizan por tener esquinas ligeramente redondeadas y una elevación (sombra) que las hace parecer flotar sobre el fondo, proporcionando una jerarquía visual clara.",
    "propiedades_detalladas": [
      {
        "nombre": "child",
        "tipo": "Widget",
        "descripcion_extendida": "El único widget que contiene la tarjeta. Es el contenido principal que se mostrará dentro de la superficie de la Card. Puedes anidar cualquier widget aquí, como `Column`, `Row`, `ListTile`, etc., para construir el diseño interno de la tarjeta.",
        "ejemplo_propiedad": "Card(\n  child: Text('Contenido dentro de la tarjeta'),\n)"
      },
      {
        "nombre": "color",
        "tipo": "Color",
        "descripcion_extendida": "Define el color de fondo de la tarjeta. Por defecto, toma el color de la superficie del tema de Material Design (`Theme.of(context).cardColor`). Puedes sobrescribirlo con cualquier color de tu elección para darle un estilo visual único a tu tarjeta.",
        "ejemplo_propiedad": "Card(\n  color: Colors.blue.shade100,\n  child: Text('Tarjeta Azul Claro'),\n)"
      },
      {
        "nombre": "elevation",
        "tipo": "double",
        "descripcion_extendida": "Controla la profundidad o \"altura\" de la tarjeta en relación con su padre. Un valor más alto crea una sombra más grande y difusa, haciendo que la tarjeta parezca más elevada y destacada. Un valor de `0.0` no muestra sombra. El valor por defecto es 1.0.",
        "ejemplo_propiedad": "Card(\n  elevation: 8.0, // Hace que la tarjeta flote más\n  child: Text('Tarjeta con sombra pronunciada'),\n)"
      },
      {
        "nombre": "shape",
        "tipo": "ShapeBorder",
        "descripcion_extendida": "Define la forma del borde de la tarjeta. Por defecto, es un `RoundedRectangleBorder` con un radio de borde pequeño. Puedes usarlo para personalizar el redondeo de las esquinas (`BorderRadius.circular()`) o incluso darle una forma completamente diferente a la tarjeta.",
        "ejemplo_propiedad": "Card(\n  shape: RoundedRectangleBorder(\n    borderRadius: BorderRadius.circular(20.0), // Esquinas muy redondeadas\n    side: BorderSide(color: Colors.red, width: 2), // Borde rojo\n  ),\n  child: Text('Tarjeta con borde personalizado'),\n)"
      },
      {
        "nombre": "margin",
        "tipo": "EdgeInsetsGeometry",
        "descripcion_extendida": "El espacio vacío alrededor de la tarjeta que la separa de otros widgets cercanos. Utiliza `EdgeInsets` para definir este espacio. El margen por defecto es `EdgeInsets.all(4.0)`. Un margen adecuado mejora la legibilidad y la organización del diseño.",
        "ejemplo_propiedad": "Card(\n  margin: EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),\n  child: Text('Tarjeta con margen lateral y vertical'),\n)"
      },
      {
        "nombre": "clipBehavior",
        "tipo": "Clip",
        "descripcion_extendida": "Define cómo se debe \"recortar\" el contenido de la tarjeta si sobresale de sus límites. Es especialmente útil cuando la tarjeta tiene esquinas redondeadas y el contenido podría desbordarse. `Clip.antiAlias` proporciona un recorte suave para bordes redondeados, evitando artefactos visuales.",
        "ejemplo_propiedad": "Card(\n  clipBehavior: Clip.antiAlias, // Asegura que el contenido se recorte suavemente con las esquinas\n  child: Image.network(\n    'https://picsum.photos/200/100', // Una imagen más grande que el Card para ver el recorte\n    fit: BoxFit.cover,\n  ),\n)"
      },
      {
        "nombre": "shadowColor",
        "tipo": "Color",
        "descripcion_extendida": "Define el color de la sombra que se dibuja debajo de la tarjeta debido a su `elevation`. Por defecto, la sombra es un tono de negro con opacidad. Puedes cambiar este color para que combine mejor con el tema de tu aplicación o para efectos visuales específicos.",
        "ejemplo_propiedad": "Card(\n  elevation: 6.0,\n  shadowColor: Colors.purple.shade200, // Sombra morada clara\n  child: Text('Tarjeta con sombra morada'),\n)"
      }
    ],
    "usos_comunes": [
      "Mostrar información agrupada y relacionada (ej. detalles de un producto, un post en un feed, una noticia).",
      "Crear elementos interactivos que puedan ser tocados para expandir información o navegar (a menudo combinados con `InkWell` o `GestureDetector`).",
      "Organizar el contenido de manera visualmente atractiva y jerárquica en un diseño Material Design."
    ],
    "constructores_comunes": [
      "Card()"
    ],
    "widgets_relacionados": [
      "Container (para contenedores más básicos sin diseño Material)",
      "Material (Card se construye sobre Material y hereda propiedades de él)",
      "InkWell (para añadir efectos visuales al tocar la Card)",
      "ListTile (a menudo usado como child dentro de una Card para elementos de lista, como en el ejemplo avanzado)"
    ],
    "cuando_no_usar": "No uses `Card` si solo necesitas un contenedor rectangular simple sin las características de Material Design (como la elevación y las esquinas redondeadas). En esos casos, un `Container` es más ligero y apropiado. También, para listas muy largas o de rendimiento crítico, el uso excesivo de `Card` para cada elemento podría tener un impacto, siendo preferible optimizar con `ListView.builder` y estructuras más simples si el diseño lo permite.",
    "codigo": "Card(\n  margin: const EdgeInsets.all(16.0),\n  elevation: 8.0,\n  shape: RoundedRectangleBorder(\n    borderRadius: BorderRadius.circular(15.0),\n  ),\n  child: Padding(\n    padding: const EdgeInsets.all(16.0),\n    child: Column(\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        const ListTile(\n          leading: Icon(Icons.album),\n          title: Text('Título de la Tarjeta'),\n          subtitle: Text('Subtítulo de la descripción.'),\n        ),\n        ButtonBar(\n          children: [\n            TextButton(onPressed: () {}, child: const Text('ACCIÓN 1')),\n            TextButton(onPressed: () {}, child: const Text('ACCIÓN 2')),\n          ],\n        ),\n      ],\n    ),\n  ),\n);",
    "imagen": "assets/Card.jpg",
    "ruta": "/Page_Card"
  },
  {
    "nombre": "Padding",
    "descripcion": "Un widget fundamental en Flutter que inserta espacio vacío alrededor de su 'child' (hijo). Permite controlar el espaciado interno de un widget, empujando su contenido lejos de sus bordes.",
    "propiedades_detalladas": [
      {
        "nombre": "padding",
        "tipo": "EdgeInsetsGeometry",
        "descripcion_extendida": "Define la cantidad de espacio vacío que se debe aplicar alrededor del 'child'. Puedes especificar un valor uniforme, solo para ciertos lados, o para lados horizontales/verticales.",
        "ejemplo_propiedad": "Padding(\n  padding: const EdgeInsets.all(16.0), // Padding uniforme de 16px\n  child: Text('Con padding de 16'),\n)\n\nPadding(\n  padding: const EdgeInsets.only(left: 8.0, top: 4.0), // Padding solo a la izquierda y arriba\n  child: Text('Con padding específico'),\n)\n\nPadding(\n  padding: const EdgeInsets.symmetric(horizontal: 20.0), // Padding horizontal\n  child: Text('Con padding horizontal'),\n)"
      },
      {
        "nombre": "child",
        "tipo": "Widget",
        "descripcion_extendida": "El widget al que se le aplicará el padding. El espacio definido por `padding` se agregará alrededor de este widget.",
        "ejemplo_propiedad": "Padding(\n  padding: const EdgeInsets.all(8.0),\n  child: Container(\n    color: Colors.blue,\n    width: 100,\n    height: 100,\n  ),\n)"
      }
    ],
    "usos_comunes": [
      "Crear espacio entre widgets en un `Column`, `Row` o `Stack`.",
      "Ajustar la separación de un widget respecto a los bordes de la pantalla o de su contenedor padre.",
      "Mejorar la legibilidad y la estética de la interfaz de usuario."
    ],
    "constructores_comunes": [
      "Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})"
    ],
    "widgets_relacionados": [
      "SizedBox",
      "Container",
      "Margin (aunque `Container` con `margin` es el equivalente común)"
    ],
    "cuando_no_usar": "No uses `Padding` si el espaciado es parte inherente del diseño de un widget personalizado (donde podrías dibujar el padding directamente). Para espaciados simples entre elementos en un `Row` o `Column`, a veces `SizedBox` con `width` o `height` puede ser una alternativa más explícita.",
    "codigo": "Padding(\n  padding: const EdgeInsets.all(12.0),\n  child: Text(\n    'Este texto tiene padding por todos lados.',\n    style: TextStyle(fontSize: 18),\n  ),\n);",
    "imagen": "assets/Padding.jpg",
    "ruta": "/Page_Padding"
  },
  {
    "nombre": "ListTile",
    "descripcion": "Un widget de Material Design que organiza de forma conveniente hasta tres líneas de texto y opcionalmente iconos iniciales y finales. Es ideal para elementos en listas, menús de navegación o cualquier lugar donde se necesite una fila de información estructurada.",
    "propiedades_detalladas": [
      {
        "nombre": "leading",
        "tipo": "Widget",
        "descripcion_extendida": "Un widget que se muestra antes del título y subtítulo. Comúnmente se usa para un `Icon`, `CircleAvatar` o `Image`.",
        "ejemplo_propiedad": "ListTile(\n  leading: Icon(Icons.person),\n  title: Text('Nombre de Usuario'),\n)"
      },
      {
        "nombre": "title",
        "tipo": "Widget",
        "descripcion_extendida": "El texto principal de la lista. Generalmente es un `Text` widget que muestra el nombre del elemento o una descripción principal.",
        "ejemplo_propiedad": "ListTile(\n  title: Text('Configuración de la Cuenta'),\n)"
      },
      {
        "nombre": "subtitle",
        "tipo": "Widget",
        "descripcion_extendida": "Texto secundario que se muestra debajo del título. Proporciona información adicional o un contexto más detallado para el elemento de la lista.",
        "ejemplo_propiedad": "ListTile(\n  title: Text('Notificaciones'),\n  subtitle: Text('Activar/Desactivar alertas'),\n)"
      },
      {
        "nombre": "trailing",
        "tipo": "Widget",
        "descripcion_extendida": "Un widget que se muestra al final de la lista, después del título y subtítulo. Se usa a menudo para iconos de flecha (`Icons.chevron_right`), `Switch` widgets o `Checkbox`.",
        "ejemplo_propiedad": "ListTile(\n  title: Text('Modo Oscuro'),\n  trailing: Switch(value: true, onChanged: (bool val) {}),\n)"
      },
      {
        "nombre": "onTap",
        "tipo": "GestureTapCallback",
        "descripcion_extendida": "Una función de callback que se invoca cuando el usuario toca el `ListTile`. Ideal para manejar la navegación o acciones al seleccionar un elemento.",
        "ejemplo_propiedad": "ListTile(\n  title: Text('Ver Detalles'),\n  onTap: () {\n    print('ListTile presionado');\n    // Navigator.push(context, MaterialPageRoute(builder: (context) => DetailScreen()));\n  },\n)"
      },
      {
        "nombre": "dense",
        "tipo": "bool",
        "descripcion_extendida": "Si es `true`, el `ListTile` será más compacto, reduciendo el espacio vertical ocupado. Útil para listas con muchos elementos.",
        "ejemplo_propiedad": "ListTile(\n  dense: true,\n  title: Text('Elemento Compacto'),\n)"
      },
      {
        "nombre": "selected",
        "tipo": "bool",
        "descripcion_extendida": "Si es `true`, el `ListTile` se dibujará con un color de fondo y de texto que indica que está seleccionado. Útil en listas de selección única o múltiple.",
        "ejemplo_propiedad": "ListTile(\n  selected: true,\n  title: Text('Elemento Seleccionado'),\n  selectedTileColor: Colors.blue.withOpacity(0.1),\n)"
      }
    ],
    "usos_comunes": [
      "Elementos en `ListView` o `Column` para mostrar información estructurada.",
      "Opciones en `Drawer` para navegación.",
      "Configuraciones en pantallas de ajustes.",
      "Listas de selección simple o múltiple."
    ],
    "constructores_comunes": [
      "ListTile()"
    ],
    "widgets_relacionados": [
      "ListView",
      "Card",
      "Divider",
      "CheckboxListTile",
      "RadioListTile"
    ],
    "cuando_no_usar": "No uses `ListTile` si necesitas un diseño de fila muy personalizado que no se ajuste a la estructura predefinida de tres líneas de texto y dos iconos. Para esos casos, considera usar `Row` y `Column` directamente para tener un control total del layout.",
    "codigo": "ListTile(\n  leading: Icon(Icons.star),\n  title: Text('Mi Elemento de Lista'),\n  subtitle: Text('Esta es una descripción secundaria.'),\n  trailing: Icon(Icons.arrow_forward_ios),\n  onTap: () {\n    print('ListTile presionado');\n  },\n);",
    "imagen": "assets/ListTile.jpg",
    "ruta": "/Page_ListTile"
  },
  {
    "nombre": "GestureDetector",
    "descripcion": "Un widget no visual que detecta gestos del usuario, como toques, arrastres o escalado, en el 'child' al que envuelve. Permite hacer que cualquier widget sea interactivo, incluso si no tiene propiedades de `onPressed` por defecto.",
    "propiedades_detalladas": [
      {
        "nombre": "child",
        "tipo": "Widget",
        "descripcion_extendida": "El widget sobre el cual se detectarán los gestos. El `GestureDetector` no tiene una representación visual propia; solo se encarga de procesar las interacciones sobre su hijo.",
        "ejemplo_propiedad": "GestureDetector(\n  child: Container(\n    color: Colors.red,\n    width: 50,\n    height: 50,\n  ),\n  onTap: () { print('Contenedor rojo tocado'); },\n)"
      },
      {
        "nombre": "onTap",
        "tipo": "GestureTapCallback",
        "descripcion_extendida": "Callback que se invoca cuando el usuario toca el widget (un 'tap' simple). Es el gesto más común y útil para acciones de clic.",
        "ejemplo_propiedad": "GestureDetector(\n  onTap: () {\n    print('Imagen tocada!');\n    // Abrir una nueva pantalla o mostrar un diálogo.\n  },\n  child: Image.asset('assets/my_image.png'),\n)"
      },
      {
        "nombre": "onDoubleTap",
        "tipo": "GestureTapCallback",
        "descripcion_extendida": "Callback que se invoca cuando el usuario realiza un doble toque rápido en el widget.",
        "ejemplo_propiedad": "GestureDetector(\n  onDoubleTap: () { print('Doble toque detectado!'); },\n  child: const Icon(Icons.favorite, size: 50),\n)"
      },
      {
        "nombre": "onLongPress",
        "tipo": "GestureLongPressCallback",
        "descripcion_extendida": "Callback que se invoca cuando el usuario mantiene presionado el widget por un tiempo prolongado.",
        "ejemplo_propiedad": "GestureDetector(\n  onLongPress: () { print('Presión prolongada!'); },\n  child: const Text('Mantén presionado'),\n)"
      },
      {
        "nombre": "onPanUpdate",
        "tipo": "GestureDragUpdateCallback",
        "descripcion_extendida": "Callback que se invoca repetidamente mientras el usuario arrastra su dedo a través del widget, proporcionando detalles sobre el movimiento.",
        "ejemplo_propiedad": "double _top = 0.0;\ndouble _left = 0.0;\n\n// ... dentro de un State\nGestureDetector(\n  onPanUpdate: (details) {\n    setState(() {\n      _top += details.delta.dy;\n      _left += details.delta.dx;\n    });\n  },\n  child: CustomPaint( // Un widget que puede reaccionar al movimiento\n    painter: MyPainter(_top, _left),\n  ),\n)"
      },
      {
        "nombre": "onTapUp",
        "tipo": "GestureTapUpCallback",
        "descripcion_extendida": "Callback que se invoca cuando el usuario levanta su dedo después de un toque. Proporciona la posición exacta donde se levantó el dedo.",
        "ejemplo_propiedad": "GestureDetector(\n  onTapUp: (details) { print('Dedo levantado en: ${details.localPosition}'); },\n  child: Container(width: 100, height: 100, color: Colors.green),\n)"
      }
    ],
    "usos_comunes": [
      "Hacer que widgets no interactivos (como `Image`, `Container`, `Text`) respondan a toques.",
      "Implementar gestos complejos como arrastrar y soltar, escalar o rotar.",
      "Detectar múltiples tipos de interacción en una sola área."
    ],
    "constructores_comunes": [
      "GestureDetector({Key? key, Widget? child, GestureTapCallback? onTap, ...})"
    ],
    "widgets_relacionados": [
      "InkWell",
      "ElevatedButton",
      "TextButton",
      "RawGestureDetector"
    ],
    "cuando_no_usar": "Si un widget ya tiene una propiedad `onPressed` o similar (como `ElevatedButton`, `ListTile`), es preferible usar esa propiedad en lugar de envolverlo en un `GestureDetector` para un simple toque, ya que los widgets interactivos nativos de Material Design a menudo manejan efectos visuales (como ripples) automáticamente.",
    "codigo": "GestureDetector(\n  onTap: () {\n    print('Widget tocado!');\n  },\n  onLongPress: () {\n    print('Widget mantenido presionado!');\n  },\n  child: Container(\n    padding: const EdgeInsets.all(20),\n    color: Colors.amber,\n    child: const Text(\n      'Toca o mantén presionado',\n      style: TextStyle(fontSize: 16),\n    ),\n  ),\n);",
    "imagen": "assets/GestureDetector.jpg",
    "ruta": "/Page_GestureDetector"
  },
  {
    "nombre": "Navigator",
    "descripcion": "Un widget que gestiona un historial de 'rutas' (páginas o pantallas) de una aplicación como una pila. Permite la navegación entre diferentes pantallas de la aplicación, empujando nuevas rutas a la pila o sacando las existentes.",
    "propiedades_detalladas": [
      {
        "nombre": "initialRoute",
        "tipo": "String",
        "descripcion_extendida": "La ruta con nombre que se mostrará inicialmente cuando se inicia la aplicación. Debe coincidir con una de las claves en el mapa de `routes`.",
        "ejemplo_propiedad": "MaterialApp(\n  initialRoute: '/',\n  routes: {\n    '/': (context) => HomeScreen(),\n    '/details': (context) => DetailScreen(),\n  },\n)"
      },
      {
        "nombre": "routes",
        "tipo": "Map<String, WidgetBuilder>",
        "descripcion_extendida": "Un mapa que asocia nombres de cadena (rutas) con funciones que construyen los widgets de la pantalla correspondiente. Es la forma más común de definir rutas con nombre para una aplicación.",
        "ejemplo_propiedad": "MaterialApp(\n  routes: {\n    '/': (context) => HomeScreen(),\n    '/profile': (context) => ProfileScreen(),\n    '/settings': (context) => SettingsScreen(),\n  },\n)"
      },
      {
        "nombre": "pushNamed",
        "tipo": "Future<T?> Function(BuildContext context, String routeName, {Object? arguments})",
        "descripcion_extendida": "Empuja una nueva ruta con nombre a la pila del navegador. La nueva ruta se muestra en la parte superior de la pantalla. Permite pasar `arguments` opcionales a la ruta de destino.",
        "ejemplo_propiedad": "ElevatedButton(\n  onPressed: () {\n    Navigator.pushNamed(\n      context,\n      '/details',\n      arguments: {'id': 42, 'name': 'Producto XYZ'},\n    );\n  },\n  child: const Text('Ir a Detalles'),\n)"
      },
      {
        "nombre": "pop",
        "tipo": "void Function(BuildContext context, [Object? result])",
        "descripcion_extendida": "Saca la ruta actual de la pila del navegador, revelando la ruta anterior. Opcionalmente, puedes pasar un `result` de vuelta a la ruta que hizo el `push`.",
        "ejemplo_propiedad": "// En la pantalla de detalles, para volver a la anterior\nElevatedButton(\n  onPressed: () {\n    Navigator.pop(context, 'Dato devuelto');\n  },\n  child: const Text('Volver'),\n)"
      },
      {
        "nombre": "popAndPushNamed",
        "tipo": "Future<T?> Function(BuildContext context, String routeName, {Object? arguments, T? result})",
        "descripcion_extendida": "Saca la ruta actual de la pila y luego empuja una nueva ruta con nombre, reemplazando la ruta anterior en la pila. Útil para reemplazar la pantalla actual sin que la anterior permanezca en el historial.",
        "ejemplo_propiedad": "ElevatedButton(\n  onPressed: () {\n    Navigator.popAndPushNamed(context, '/home');\n  },\n  child: const Text('Ir a Inicio y cerrar actual'),\n)"
      },
      {
        "nombre": "pushReplacementNamed",
        "tipo": "Future<T?> Function(BuildContext context, String routeName, {Object? arguments, T? result})",
        "descripcion_extendida": "Reemplaza la ruta actual con una nueva ruta con nombre. La ruta actual se elimina de la pila y la nueva se coloca en su lugar. Es similar a `popAndPushNamed` en efecto.",
        "ejemplo_propiedad": "ElevatedButton(\n  onPressed: () {\n    // Usar después de un login para que el usuario no pueda volver a la pantalla de login\n    Navigator.pushReplacementNamed(context, '/dashboard');\n  },\n  child: const Text('Login y entrar'),\n)"
      }
    ],
    "usos_comunes": [
      "Gestionar la navegación entre todas las pantallas de una aplicación Flutter.",
      "Manejar el historial de navegación (pila de pantallas).",
      "Pasar datos entre pantallas (con `arguments`).",
      "Controlar el flujo de la aplicación (ej. después de un login, reemplazar la pantalla de login con la principal)."
    ],
    "constructores_comunes": [
      "No se construye directamente, se accede a través de `Navigator.of(context)` o métodos estáticos como `Navigator.pushNamed()`."
    ],
    "widgets_relacionados": [
      "MaterialApp (donde se configuran las rutas)",
      "PageRoute (como MaterialPageRoute o CupertinoPageRoute)",
      "ModalRoute (para acceder a los argumentos)",
      "WillPopScope (para controlar el botón de retroceso del dispositivo)"
    ],
    "cuando_no_usar": "No es apropiado usar `Navigator` para cambios de UI pequeños dentro de una misma pantalla (ej. mostrar/ocultar un widget, cambiar un estado local). Para eso, usa `StatefulWidget` y `setState` o soluciones de gestión de estado como `Provider`, `Riverpod`, `Bloc`, etc.",
    "codigo": "class MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'App con Navegación',\n      initialRoute: '/',\n      routes: {\n        '/': (context) => const HomeScreen(),\n        '/details': (context) => const DetailScreen(),\n        '/settings': (context) => const SettingsScreen(),\n      },\n      onGenerateRoute: (settings) {\n        // Un ejemplo avanzado para manejar rutas no definidas o con lógica compleja\n        if (settings.name == '/product') {\n          final args = settings.arguments as Map<String, dynamic>;\n          return MaterialPageRoute(builder: (context) => ProductScreen(productId: args['id']));\n        }\n        return null; // Dejar que el sistema maneje otras rutas\n      },\n    );\n  }\n}\n\n// Ejemplo de HomeScreen\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Inicio')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            ElevatedButton(\n              onPressed: () {\n                Navigator.pushNamed(context, '/details',\n                    arguments: {'data': 'Información desde Home'});\n              },\n              child: const Text('Ir a Detalles'),\n            ),\n            ElevatedButton(\n              onPressed: () {\n                Navigator.pushNamed(context, '/settings');\n              },\n              child: const Text('Ir a Ajustes'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Ejemplo de DetailScreen\nclass DetailScreen extends StatelessWidget {\n  const DetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final Map<String, dynamic>? args = ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>?;\n    final String receivedData = args?['data'] ?? 'Sin datos';\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detalles')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text('Datos recibidos: $receivedData'),\n            ElevatedButton(\n              onPressed: () {\n                Navigator.pop(context, 'Resultado desde Detalles');\n              },\n              child: const Text('Volver con resultado'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
    "imagen": "assets/Navigator.jpg",
    "ruta": "/Page_Navigator"
}
]